# check-performance [ファイルパスまたはディレクトリパス]

指定されたファイル/ディレクトリのパフォーマンス問題を**ファイル単位で精密に**検出し、詳細なサマリーを出力します。

---

## 🎯 基本方針

- **1ファイル = 1サイクル**: 必ず1ファイルずつ完全に調査してから次へ進む
- **精密調査**: ファイル全体を読み込み、全メソッド/関数を分析
- **進捗可視化**: TodoWriteツールで調査の進捗を記録
- **具体性重視**: 推測ではなく、実際のコードと行番号で問題を特定

---

## 📋 実行手順

### STEP 0: 調査開始前の準備（MUST）

対象ファイルが複数ある場合は、**必ずTodoWriteツールで調査計画を作成**してから開始すること:

```
例:
- [ ] 対象ファイルをリストアップ (pending)
- [ ] xxx_worker.rb を精密調査 (pending)
- [ ] yyy_service.rb を精密調査 (pending)
- [ ] 最終サマリーを作成 (pending)
```

**調査中の更新ルール:**
- ファイル調査開始時: タスクを `in_progress` に変更
- ファイル調査完了時: タスクを `completed` に変更

---

### STEP 1: 対象ファイルの列挙と優先順位付け

引数に基づいて解析対象を決定:

#### パターン1: ファイルパスが指定された場合
- そのファイルのみを対象とする
- 1ファイルのみなのでTodoリストは不要

#### パターン2: ディレクトリパスが指定された場合
1. Globツールを使用してディレクトリ以下の対象ファイルを全て列挙
   - Ruby: `**/*.rb`
   - TypeScript/JavaScript: `**/*.{ts,tsx,js,jsx}`
2. ファイル数をカウント
3. 優先順位でソート（下記の順序）
4. TodoWriteツールで各ファイルを個別タスクとして登録

**ファイルの優先順位:**
1. Workerファイル（`app/workers/**/*_worker.rb`）- N+1問題の温床
2. Serviceファイル（`app/services/**/*.rb`）
3. Controllerファイル（`app/controllers/**/*_controller.rb`）
4. Modelファイル（`app/models/**/*.rb`）
5. その他

#### パターン3: 引数なしの場合
- 現在のブランチとstagingブランチの差分変更内容を調査する
- `git diff staging --name-only` で差分ファイルを取得
- 優先順位でソート後、TodoWriteツールで登録

**重要:**
- 対象ファイルが2件以上の場合は、必ずTodoWriteツールでタスクリストを作成すること

---

### STEP 2: ファイルごとの精密調査（各ファイルで必ず実行）

**⚠️ 重要: 以下の手順を1ファイルずつ完全に実行すること**
**⚠️ 複数ファイルを同時に調査することは禁止**

#### 2-1. ファイル読み込み（MUST）

1. **Readツールでファイル全体を読み込む**
   - ファイルの全行を確認する（部分的な読み込みは禁止）

2. **ファイルの構造を理解する**
   - ファイルの目的・役割を把握
   - 主要なメソッド/関数をリストアップ
   - 依存関係を確認

#### 2-2. 詳細分析（MUST）

各メソッド/関数について、以下のチェックを順番に実行:

---

##### ✅ チェック0: `includes` の不適切な使用（🔴 最高優先度）

**検出対象:**
ファイル内のすべての `.includes(` パターン

**検出方法:**
1. Grepツールで `\.includes\(` を検索
2. または Readツールで読み込んだファイル内を検索

**判定基準:**
`includes` を発見した場合、WHERE句の使用状況を確認：
- WHERE句で関連テーブルのカラムを使用 → `eager_load` に変更（巨大テーブルでないこと確認必須）
- WHERE句で関連テーブルを使用しない → `preload` に変更（推奨）

**NG例とOK例:**
```ruby
# ❌ NG: includesの使用（Railsが自動判定するため予測不能）
Model.includes(:association).each { |m| ... }

# ✅ OK: preloadを使用（基本はこちら）
Model.preload(:association).each { |m| ... }

# ✅ OK: eager_loadを使用（WHERE句で関連テーブルを絞り込む場合のみ）
Model.eager_load(:association).where(associations: { active: true }).each { |m| ... }
```

**なぜ問題か:**
- Railsが自動判定するため、JOIN/複数クエリのどちらになるか予測不能
- 巨大テーブルをJOINした場合、メモリ枯渇のリスク
- エンジニアが明示的に制御する必要がある

**記録内容:**
- 該当行番号、実際のコード
- WHERE句の有無
- 推奨する変更先（`preload` または `eager_load`）

---

##### ✅ チェック1: N+1クエリ問題（🔴 高優先度）

**検出対象:**
- ループ内でのActiveRecord呼び出し（`each`, `map`, `select` 等）
- アソシエーション呼び出しでの事前読み込み未使用
- 同じテーブルへの繰り返しクエリ

**検出方法:**
1. ループ処理をすべて特定（ネストしたループも確認）
2. ループ内でのデータベースアクセスを確認
3. `preload`/`eager_load` の使用状況を確認

**判定基準:**
ループ内でアソシエーションにアクセスしている場合は N+1 の可能性が高い

**NG例とOK例:**
```ruby
# ❌ NG: ループ内でアソシエーションにアクセス
users.each { |u| u.posts.count }  # N+1発生

# ✅ OK: 事前読み込み
User.preload(:posts).each { |u| u.posts.count }

# ❌ NG: 繰り返しfindを実行
ids.each { |id| Model.find(id) }  # N回のクエリ

# ✅ OK: まとめて取得
records = Model.where(id: ids).index_by(&:id)
ids.each { |id| records[id] }
```

**なぜ問題か:**
- クエリ回数が増加し、レスポンスタイムが劇的に悪化
- データ量増加で指数関数的に遅くなる

**記録内容:**
- 該当行番号、実際のコード
- N+1問題の可能性（高/中/低）

---

##### ✅ チェック2: 非効率なループ処理（🟡 中優先度）

**検出対象:**
- 大量データの `.all.each` パターン
- ネストした繰り返し処理
- 非効率なアルゴリズム（O(n²)等）

**検出方法:**
1. すべての繰り返し処理を特定し、ネストレベルを記録
2. ループ内の処理内容を確認
3. `find_each`/`find_in_batches` への置き換え可能性を検討

**判定基準:**
- 大量データ（1000件以上目安）を `.all.each` で処理している
- ネストしたループで配列検索を行っている

**NG例とOK例:**
```ruby
# ❌ NG: 全レコードをメモリに読み込み
Model.all.each { |m| ... }

# ✅ OK: バッチ処理
Model.find_each(batch_size: 1000) { |m| ... }

# ❌ NG: O(n²)のアルゴリズム
users.each { |u| depts.find { |d| d.id == u.dept_id } }

# ✅ OK: O(n)に改善
dept_hash = depts.index_by(&:id)
users.each { |u| dept_hash[u.dept_id] }
```

**なぜ問題か:**
- CPU/メモリ使用量の増大
- レスポンスタイムの悪化

**記録内容:**
- 該当行番号、ループの種類とネストレベル
- ループ内の処理内容

---

##### ✅ チェック3: クエリの重複・不要なクエリ（🟡 中優先度）

**検出対象:**
- 同じクエリの重複実行
- 不要なクエリ（`exists?` の後に再取得など）

**検出方法:**
1. 同じようなクエリパターンを探す
2. クエリ結果の再利用可能性を確認

**判定基準:**
同じ条件のクエリが複数回実行されている

**NG例とOK例:**
```ruby
# ❌ NG: 同じクエリを2回実行
if Model.where(id: x).exists?
  records = Model.where(id: x)
end

# ✅ OK: クエリ結果を再利用
records = Model.where(id: x)
if records.exists?
  # recordsを使用
end
```

**なぜ問題か:**
- 不要なデータベース負荷
- レスポンスタイムの悪化

**記録内容:**
- 該当行番号、クエリの内容
- 重複/不要と判断した理由

---

##### ✅ チェック4: メモリリーク（🟡 中優先度）

**検出対象:**
- 大きな配列/ハッシュの生成（`.all`, `.to_a` の使用）
- ループ内での配列への追加（`<<`, `push`）

**検出方法:**
1. `.all`, `.to_a` の使用箇所を確認
2. ループ内で配列にデータを蓄積しているパターンを探す
3. バッチ処理の使用状況を確認

**判定基準:**
大量データをメモリに蓄積している

**NG例とOK例:**
```ruby
# ❌ NG: 大量データを配列に蓄積
all_data = []
Model.find_each { |m| all_data << process(m) }

# ✅ OK: 都度処理
Model.find_each { |m| process(m) }
```

**なぜ問題か:**
- メモリ使用量の急増
- OOM（Out of Memory）エラーの可能性

**記録内容:**
- 該当行番号、メモリ使用の懸念内容
- 推定データ量

---

##### ✅ チェック5: React再レンダリング（🟡 中優先度）

**対象:** TypeScript/JavaScriptファイルのみ

**検出対象:**
- コンポーネント内でのオブジェクト/配列生成
- `useMemo`, `useCallback` の未使用
- `useEffect` の不適切な依存配列

**検出方法:**
1. コンポーネント関数内でのオブジェクト/配列リテラルを探す
2. `useMemo`, `useCallback` の使用状況を確認
3. `useEffect` の依存配列を確認

**判定基準:**
propsに渡すオブジェクト/配列が毎回新しく生成されている

**NG例とOK例:**
```tsx
// ❌ NG: 毎回新しいオブジェクト生成
const C = () => {
  const data = { key: 'value' };
  return <Child data={data} />;
};

// ✅ OK: メモ化
const C = () => {
  const data = useMemo(() => ({ key: 'value' }), []);
  return <Child data={data} />;
};
```

**なぜ問題か:**
- 不要な再レンダリングによるパフォーマンス低下

**記録内容:**
- 該当行番号、問題の内容
- 最適化手法の提案

---

#### 2-3. 問題の記録（MUST）

発見した問題を以下の形式で記録:

```
問題ID: [ファイル名]_[連番]
ファイル: [ファイルパス]:[行番号]
優先度: 🔴最高（includes使用） / 🔴高 / 🟡中 / 🟢低
カテゴリ: includes不適切使用 / N+1問題 / 非効率なループ / クエリ重複 / メモリリーク / React再レンダリング
問題の概要: [1行で]
詳細: [なぜ問題か、どの程度の影響か]
該当コード: [実際のコード3-5行]
修正案: [具体的な修正例（includesの場合はpreload/eager_loadのどちらを推奨するか明記）]
期待される改善: [定量的に]
```

#### 2-4. 次のファイルへ進む前のチェックリスト（MUST）

以下をすべて満たしてから次のファイルへ進むこと:

- [ ] Readツールでファイル全体を読み込んだ
- [ ] 全メソッド/関数を分析した
- [ ] **チェック0（`includes`検出）を必ず実行した** 🔴
- [ ] チェック1〜5をすべて実行した
- [ ] 発見した問題をすべて記録した
- [ ] 行番号をすべて確認した
- [ ] 「問題なし」の場合もその理由を記録した
- [ ] TodoWriteで当該ファイルを `completed` に変更した

**禁止事項:**
- ❌ ファイルの一部だけ見て判断する
- ❌ 推測で問題があると決めつける
- ❌ 行番号を確認せずに進む
- ❌ 問題を記録せずに次へ進む
- ❌ `includes` を見落とす

---

### STEP 3: 最終サマリーの作成

全ファイルの調査が完了したら、以下の形式で統合サマリーを出力:

---

## 📊 出力フォーマット

### パフォーマンスチェック結果

**調査方式**: ファイル単位の精密調査
**対象**: [ファイルパス/ディレクトリパス/ブランチ差分]
**調査開始**: [開始時刻]
**調査完了**: [完了時刻]
**調査完了ファイル数**: X件
**検出問題数**: Y件（🔴最高: Z, 🔴高: A, 🟡中: B, 🟢低: C）

**⚠️ includes使用箇所**: Z件（すべて即座に対応必要）

---

### 📁 ファイルごとの調査結果

#### ファイル1: `[相対パス]`

**ファイル概要**: [ファイルの役割・目的]
**主要メソッド**: [メソッド/関数一覧]
**検出問題数**: X件（🔴: A, 🟡: B, 🟢: C）

**問題詳細**:

##### 問題1-1: [問題の概要]

**行番号**: [行番号]
**優先度**: 🔴 高
**カテゴリ**: N+1問題

**問題点**:
[なぜ問題か - 具体的な影響]

**該当コード**:
```[言語]
[実際のコード（3-5行程度）]
```

**修正案**:
```[言語]
[具体的な修正例]
```

**期待される改善**:
[修正によるパフォーマンス改善の見込み]

---

#### ファイル2: `[相対パス]`

**ファイル概要**: [ファイルの役割・目的]
**主要メソッド**: [メソッド/関数一覧]
**検出問題数**: 0件

**調査結果**:
現時点で明確なパフォーマンス問題は検出されませんでした。

**改善提案**:
- [将来的な改善案がある場合]
- [監視すべきポイントがある場合]

---

### 🔴 最高優先度の問題まとめ: `includes` の不適切な使用 (Z件)

1. **[ファイル名]:[行番号]** - `includes` → `preload` / `eager_load` に変更
2. **[ファイル名]:[行番号]** - `includes` → `preload` / `eager_load` に変更

**推奨アクション:**
- WHERE句で関連テーブルを絞り込んでいるか確認
- 絞り込みなし → `preload` に変更（推奨）
- 絞り込みあり → `eager_load` に変更（巨大テーブルでないこと確認）

---

### 🔴 高優先度の問題まとめ (A件)

1. **[ファイル名]:[行番号]** - [問題の概要]
2. **[ファイル名]:[行番号]** - [問題の概要]

---

### 🟡 中優先度の問題まとめ (B件)

1. **[ファイル名]:[行番号]** - [問題の概要]
2. **[ファイル名]:[行番号]** - [問題の概要]

---

### 🟢 低優先度の問題まとめ (C件)

1. **[ファイル名]:[行番号]** - [問題の概要]
2. **[ファイル名]:[行番号]** - [問題の概要]

---

### 💡 推奨アクション

**🔴 最優先（今すぐ対応）**:
1. **`includes` の全置き換え**
   - すべての `includes` を `preload` または `eager_load` に変更
   - 基本的には `preload` を使用（メモリ効率的）
   - WHERE句で関連テーブルを絞り込む場合のみ `eager_load`（巨大テーブルでないこと確認）

**即座に対応すべき項目**:
1. [高優先度の問題の具体的な対応指示]

**早めに対応すべき項目**:
1. [中優先度の問題の具体的な対応指示]

**余裕があれば対応**:
1. [低優先度の問題の具体的な対応指示]

**総評**:
[全体的なパフォーマンス評価と今後の方針]

---

## ✅ 精密調査の品質基準（MUST）

各ファイルの調査で以下を満たすこと:

### 完全性
- ファイルの全行を確認した
- 全メソッド/関数を分析した
- 見落としがないことを確認した

### 具体性
- 問題箇所の行番号をすべて特定した
- 実際のコードを引用した
- 推測ではなく確認した内容のみ記載

### 深さ
- 表面的なチェックではなく、ロジックを理解した
- なぜ問題なのかを説明できる
- 具体的な影響を見積もった

### 記録
- 発見した問題をすべて記録した
- 「問題なし」の場合もその理由を記録した
- 次のファイルに進む前に記録を完了した

---

## ❌ 制約事項（MUST NOT）

### 禁止事項

1. **複数ファイルを同時に調査する**
   → 必ず1ファイルずつ完全に調査する

2. **ファイルの一部だけを読んで判断する**
   → Readツールでファイル全体を確認する

3. **行番号を確認せずに問題を指摘する**
   → すべての問題箇所の行番号を特定する

4. **推測で問題があると決めつける**
   → 実際のコードを確認してから判断する

5. **Todoリストなしでディレクトリ調査を開始する**
   → 複数ファイルの場合は必ずTodoリストを作成

6. **調査の進捗を記録せずに次へ進む**
   → 各ファイルの調査完了をTodoで記録

### 必須事項

1. **1ファイルずつ完全に調査する**
   → 次のファイルに進む前に100%完了させる

2. **Readツールで必ずファイル全体を確認する**
   → 部分的な読み込みは禁止

3. **すべての問題箇所の行番号を特定する**
   → 「このあたり」のような曖昧な指摘は禁止

4. **各ファイルの調査完了をTodoで記録する**
   → ユーザーに進捗を可視化する

5. **調査プロセスを透明化する**
   → 何をチェックしているか明示する

6. **問題が見つからない場合もその旨を記録する**
   → 「問題なし」も重要な調査結果

---

## 📚 使用例

```bash
# 特定ファイルを精密調査
/check-performance packs/hatsurei/app/workers/hatsurei/personnel_changes_bulk_confirm_worker.rb

# ディレクトリ全体を1ファイルずつ精密調査
/check-performance packs/hatsurei/app/workers/

# 現在のブランチとstagingブランチの差分変更内容を1ファイルずつ精密調査
/check-performance
```

